import '/os'
import '/datetime/datetime'
import '/collections/deque'
import '/collections/defaultdict'

import 'Post'
import 'Tree'
import 'Board'
import 'Thread'
import 'markup'
import '../config'


remove_uploads = obj -> for (fn, thumb) in obj.files =>
  fn    => os.unlink $ os.path.join config.UPLOAD_DIR fn
  thumb => os.unlink $ os.path.join config.UPLOAD_DIR thumb


commands = data ->
  # Cutting corners wherever possible.
  # Using these cells instead of `data` allows us
  # to replace a dict lookup with two pointer lookups.
  RP_COUNT  = data !! 'ids'       # :: {str: int}
  RP_BOARD  = data !! 'boards'    # :: {str: Board}
  RP_CATMAP = data !! 'boardmap'  # :: {str: {str: str}}
  RP_POSTS  = data !! 'posts'     # :: {str: {int: Post}}
  RP_TREES  = data !! 'trees'     # :: {str: {int: Either Thread Tree}}

  # Various data that can be derived from the above stuff.
  VD_ATTACHED = dict (None where
    # An {str: int} mapping that contains the number of attached threads
    # on each board.
    for (n, b) in RP_BOARD.items! => yield (n, next (None where
      for (i, t) in enumerate b.threads => not t.attached => yield i
      yield $ len b.threads)))

  # Volatile cache containers.
  # These are in the database because that
  #   1. allows flask workers to share cache;
  #   2. makes invalidating them easier.
  VC_BOARD  = defaultdict dict  # :: {str: {int: str}}
  VC_THREAD = defaultdict dict  # :: {(str, int): {str: str}}

  post_cleanup = None
  post_cleanup = board num ->
    postobj   = (RP_POSTS !! board).pop num
    treeobj   = (RP_TREES !! board).pop num
    threadobj = (RP_TREES !! board).get postobj.thread None
    remove_uploads postobj
    if threadobj and (threadobj.latest !! 0).id <= num => threadobj.latest.remove postobj
    for subtree in treeobj.replies => post_cleanup board subtree.root.id

  dict'
    # :: -> ()
    'clear_cache', ->
      VC_BOARD.clear!
      VC_THREAD.clear!

    # :: str int     -> Maybe str
    # :: str int str -> ()
    'get_cached_board', name page   -> (VC_BOARD !! name).get page
    'set_cached_board', name page x -> (VC_BOARD !! name).__setitem__ page x

    # :: str int str     -> Maybe str
    # :: str int str str -> ()
    'get_cached_thread', board num vt   -> (VC_THREAD !! (board, num)).get vt
    'set_cached_thread', board num vt x -> (VC_THREAD !! (board, num)).__setitem__ vt x

    # ::         -> {str: {str: str}}
    # :: str int -> Post
    # :: str int -> Either Thread Tree
    'boards',           -> RP_CATMAP
    'post',   board num -> RP_POSTS !! board !! num
    'thread', board num ->
      th = RP_TREES !! board !! num
      th :: Tree => raise KeyError
      th

    # Fetch a list of threads on a board.
    # Also returns the title of the board and the number of pages.
    #
    # :: str int -> (str, [Thread], int)
    #
    'board', name page ->
      board    = RP_BOARD !! name
      pages, r = len board.threads `divmod` config.THREADS_PER_PAGE

      data = None where
        n = page * config.THREADS_PER_PAGE
        for t in board.threads !! slice n (n + config.THREADS_PER_PAGE) =>
          # To reduce the amount of data transferred to the web server,
          # reply trees are removed.
          yield $ Thread t.root None t.latest t.skipped t.attached t.closed

      board.title, list data, pages + bool r

    # Create a new board or update the old one.
    #
    # :: str str str -> ()
    #
    'board_create', name title category ->
      if
        name in RP_BOARD =>
          old = RP_BOARD !! name
          RP_BOARD  !! name = Board name title category old.threads
          RP_CATMAP !! old.category !!~ name
        otherwise =>
          RP_COUNT !! name = 0
          RP_BOARD !! name = Board name title category list!
          RP_POSTS !! name = dict!
          RP_TREES !! name = dict!
          VD_ATTACHED !! name = 0
      RP_CATMAP !! category = RP_CATMAP.get category dict!
      RP_CATMAP !! category !! name = title
      None

    # Create a new thread, return its ID.
    #
    # :: str str str [(str, str)] str -> int
    #
    'thread_create', board title text files ip ->
      boardo = RP_BOARD !! board
      rootid = RP_COUNT !! board += 1
      root   = Post rootid title False (markup.parse text) files rootid 0 datetime.now! ip
      thread = Thread root list! list! 0 False False

      boardo.threads.insert (VD_ATTACHED !! board) thread
      config.THREADS_PER_BOARD < len boardo.threads =>
        cn = boardo.threads.pop -1
        post_cleanup board cn.root.id

      VC_BOARD.pop board None  # All pages are invalid now.
      RP_TREES !! board !! rootid = thread
      RP_POSTS !! board !! rootid = root
      rootid

    # Set the `closed` flag of a thread.
    # Closed threads cannot be replied to.
    # Note that this is independent of a reply count limit.
    #
    # :: str int bool -> ()
    #
    'thread_set_closed', board num state ->
      state  = bool state
      thread = RP_TREES !! board !! num
      if thread :: Tree         => raise KeyError
         thread.closed is state => None
         otherwise              =>
           thread.closed = bool state
           # Since there's probably some kind of icon for that,
           # the cache is now invalid.
           VC_BOARD.pop   board       None
           VC_THREAD.pop (board, num) None
           None

    # Set the `attached` flag of a thread.
    # Attached threads always appear at the top of the first page.
    #
    # :: str int bool -> ()
    #
    'thread_set_attached', board num state ->
      state  = bool state
      boardo = RP_BOARD !! board
      thread = RP_TREES !! board !! num
      if thread :: Tree           => raise KeyError
         thread.attached is state => None
         otherwise =>
           thread.attached = state
           VD_ATTACHED !! board -= not state
           boardo.threads.remove                        thread
           boardo.threads.insert (VD_ATTACHED !! board) thread
           VD_ATTACHED !! board += state
           VC_BOARD.pop   board       None
           VC_THREAD.pop (board, num) None
           None

    # Create a new reply, return its ID.
    #
    # :: str int str bool str [(str, str)] str -> int
    #
    'post_create', board parent title sage text files ip ->
      boardobj  = RP_BOARD !! board
      parentobj = RP_POSTS !! board !! parent
      treeobj   = RP_TREES !! board !! parent
      threadobj = RP_TREES !! board !! parentobj.thread

      threadlen = len threadobj.latest + threadobj.skipped
      threadlen >= config.POSTS_UNTIL_AUTOSAGE => sage = True
      threadlen >= config.POSTS_PER_THREAD     => raise OverflowError
      threadobj.closed                         => raise OverflowError

      postid  = RP_COUNT !! board += 1
      postobj = Post postid title sage (markup.parse text) files parentobj.thread parent datetime.now! ip
      curtree = Tree postobj list!

      RP_POSTS !! board !! postid = postobj
      RP_TREES !! board !! postid = curtree
      treeobj.replies.append curtree
      threadobj.latest.append postobj

      len threadobj.latest > config.POSTS_ON_BOARD_PAGE =>
        threadobj.latest.pop 0
        threadobj.skipped += 1

      not sage and not threadobj.attached =>
        boardobj.threads.remove                        threadobj
        boardobj.threads.insert (VD_ATTACHED !! board) threadobj

      VC_BOARD.pop   board                  None
      VC_THREAD.pop (board, postobj.thread) None
      postid

    # :: str -> ()
    'board_remove', name ->
      board = RP_BOARD.pop name
      for p in (RP_POSTS !! name).values! => remove_uploads p
      RP_CATMAP !! board.category !!~ name
      RP_CATMAP !! board.category or RP_CATMAP !!~ board.category
      RP_POSTS !!~ name
      RP_TREES !!~ name
      RP_COUNT !!~ name
      VD_ATTACHED !!~ name
      VC_BOARD.pop name None
      VC_THREAD.clear!

    # :: str int -> ()
    'post_remove', board num ->
      curtree = RP_TREES !! board !! num
      if curtree :: Thread => (RP_BOARD !! board).threads.remove curtree
         otherwise =>
           treeobj = RP_TREES !! board !! curtree.root.parent
           treeobj.replies.remove curtree

      post_cleanup board num
      VC_BOARD.pop   board                       None
      VC_THREAD.pop (board, curtree.root.thread) None
