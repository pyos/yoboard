import '/datetime/datetime'
import '/collections/deque'
import '/collections/defaultdict'

import 'Post'
import 'Tree'
import 'Board'
import 'Thread'
import 'IntRef'
import '../config'
import '../markup'


commands = data ->
  # Cutting corners wherever possible.
  # Using these cells instead of `data` allows us
  # to replace a dict lookup with two pointer lookups.
  RP_COUNT  = data !! 'ids'       # :: {str: int}
  RP_BOARD  = data !! 'boards'    # :: {str: Board}
  RP_CATMAP = data !! 'boardmap'  # :: {str: {str: str}}
  RP_THREAD = data !! 'threads'   # :: {str: {int: Thread}}
  RP_POST   = data !! 'posts'     # :: {str: {int: Post}}
  # Volatile cache containers.
  # These are in the database because that
  #   1. allows flask workers to share cache;
  #   2. makes invalidating them easier.
  VC_BOARD  = defaultdict dict  # :: {str: {int: str}}
  VC_THREAD = defaultdict dict  # :: {(str, int): {str: str}}

  dict'
    # :: -> ()
    'clear_cache', ->
      VC_BOARD.clear!
      VC_THREAD.clear!

    # :: str int     -> Maybe str
    # :: str int str -> ()
    'get_cached_board', name page   -> (VC_BOARD !! name).get page
    'set_cached_board', name page x -> (VC_BOARD !! name).__setitem__ page x

    # :: str int str     -> Maybe str
    # :: str int str str -> ()
    'get_cached_thread', board num vt   -> (VC_THREAD !! (board, num)).get vt
    'set_cached_thread', board num vt x -> (VC_THREAD !! (board, num)).__setitem__ vt x

    # ::         -> {str: {str: str}}
    # :: str int -> Thread
    'boards',           -> RP_CATMAP
    'thread', board num -> RP_THREAD !! board !! num

    # Fetch a list of threads on a board.
    # Also returns the title of the board and the number of pages.
    #
    # :: str int -> (str, [Thread], int)
    #
    'board', name page ->
      board    = RP_BOARD !! name
      pages, r = len board.threads `divmod` config.THREADS_PER_PAGE

      data = None where
        n = page * config.THREADS_PER_PAGE
        for t in take config.THREADS_PER_PAGE (drop n board.threads) =>
          # To reduce the amount of data transferred to the web server,
          # reply trees are removed.
          yield $ Thread t.root None t.latest t.skipped
  
      board.title, list data, pages + bool r

    # Create a new board or update the old one.
    #
    # :: str str str -> ()
    #
    'board_create', name title category ->
      if
        name in RP_BOARD =>
          old = RP_BOARD !! name
          RP_BOARD  !! name = Board name title category old.threads
          RP_CATMAP !! old.category !!~ name
        otherwise =>
          RP_COUNT  !! name = 0
          RP_BOARD  !! name = Board name title category list!
          RP_POST   !! name = dict!
          RP_THREAD !! name = dict!
      RP_CATMAP !! category = RP_CATMAP.get category dict!
      RP_CATMAP !! category !! name = title
      None

    # Create a new thread, return its ID.
    #
    # :: str str str [(str, str)] -> int
    #
    'thread_create', board title text files ->
      boardo = RP_BOARD !! board
      rootid = RP_COUNT !! board += 1
      root   = Post rootid title False (markup.parse text) files 0 0 datetime.now!
      thread = Thread root list! list! (IntRef 0)

      boardo.threads.insert 0 thread
      config.THREADS_PER_BOARD < len boardo.threads => boardo.threads.pop -1

      VC_BOARD.pop board None  # All pages are invalid now.
      RP_THREAD !! board !! root.id = thread
      RP_POST   !! board !! root.id = root
      rootid

    # Create a new reply, return its ID.
    #
    # :: str int int str bool str [(str, str)] -> int
    #
    'post_create', board thread parent title sage text files ->
      # First, we check `thread` and `parent`.
      # If either of these raises a KeyError, one of the
      # values is completely invalid.
      bo = RP_BOARD  !! board
      th = RP_THREAD !! board !! thread
      pp = RP_POST   !! board !! parent
      tl = len th.latest + th.skipped.value
  
      # First-and-a-half, we check the thread's constraints.
      tl >= config.POSTS_UNTIL_AUTOSAGE => sage = True
      tl >= config.POSTS_PER_THREAD     => raise OverflowError
  
      # Second, we trace the parenting chain to its origin.
      # We need that info to descend into the correct tree.
      ps  = deque!
      pid = parent
      while pid =>
        ps.append pid
        pid = (RP_POST !! board !! pid).parent
  
      if (expected = ps.pop!) != thread =>
        # If the tip of the tree does not match the thread ID,
        # something got mixed up.
        raise $ ValueError 'wrong thread' expected thread
  
      # Third, we commence the aforementioned descent
      # into the tree.
      pt = th
      while ps and (pid = ps.pop!) =>
        # The trees are, unfortunately, ordered by root ID.
        # That would allow us to use binary search, if it wasn't that cumbersome.
        pt = next (None where for t in pt.replies => if t.root.id == pid => yield t)
  
      # From this point on we cannot afford to bail out.
      id = RP_COUNT !! board += 1
      po = Post id title sage (markup.parse text) files thread parent datetime.now!
      th.latest.append po
      pt.replies.append $ Tree po list!
      RP_POST !! board !! po.id = po
  
      len th.latest > config.POSTS_ON_BOARD_PAGE =>
        th.latest.pop 0
        th.skipped.value += 1
  
      not sage =>
        bo.threads !!~ next (None where
          for (i, t) in enumerate bo.threads =>
            if t.root.id == thread => yield i)
        bo.threads.insert 0 th

      # Note that not all pages have become invalid, but we don't care.
      VC_BOARD.pop board None
      VC_THREAD.pop (board, thread) None
      po.id
