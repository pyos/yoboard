import '/datetime/datetime'
import '/collections/deque'
import '/collections/defaultdict'

import 'Post'
import 'Tree'
import 'Board'
import 'Thread'
import 'IntRef'
import '../config'
import '../markup'


commands = data ->
  # Cutting corners wherever possible.
  # Using these cells instead of `data` allows us
  # to replace a dict lookup with two pointer lookups.
  RP_COUNT  = data !! 'ids'       # :: {str: int}
  RP_BOARD  = data !! 'boards'    # :: {str: Board}
  RP_CATMAP = data !! 'boardmap'  # :: {str: {str: str}}
  RP_THREAD = data !! 'threads'   # :: {str: {int: Thread}}
  RP_POST   = data !! 'posts'     # :: {str: {int: Post}}
  # Volatile cache containers.
  # These are in the database because that
  #   1. allows flask workers to share cache;
  #   2. makes invalidating them easier.
  VC_BOARD  = defaultdict dict  # :: {str: {int: str}}
  VC_THREAD = defaultdict dict  # :: {(str, int): {str: str}}

  dict'
    # :: -> ()
    'clear_cache', ->
      VC_BOARD.clear!
      VC_THREAD.clear!

    # :: str int     -> Maybe str
    # :: str int str -> ()
    'get_cached_board', name page   -> (VC_BOARD !! name).get page
    'set_cached_board', name page x -> (VC_BOARD !! name).__setitem__ page x

    # :: str int str     -> Maybe str
    # :: str int str str -> ()
    'get_cached_thread', board num vt   -> (VC_THREAD !! (board, num)).get vt
    'set_cached_thread', board num vt x -> (VC_THREAD !! (board, num)).__setitem__ vt x

    # ::         -> {str: {str: str}}
    # :: str int -> Thread
    'boards',           -> RP_CATMAP
    'thread', board num -> RP_THREAD !! board !! num

    # Fetch a list of threads on a board.
    # Also returns the title of the board and the number of pages.
    #
    # :: str int -> (str, [Thread], int)
    #
    'board', name page ->
      board    = RP_BOARD !! name
      pages, r = len board.threads `divmod` config.THREADS_PER_PAGE

      data = None where
        n = page * config.THREADS_PER_PAGE
        for t in take config.THREADS_PER_PAGE (drop n board.threads) =>
          # To reduce the amount of data transferred to the web server,
          # reply trees are removed.
          yield $ Thread t.root None t.latest t.skipped
  
      board.title, list data, pages + bool r

    # Create a new board or update the old one.
    #
    # :: str str str -> ()
    #
    'board_create', name title category ->
      if
        name in RP_BOARD =>
          old = RP_BOARD !! name
          RP_BOARD  !! name = Board name title category old.threads
          RP_CATMAP !! old.category !!~ name
        otherwise =>
          RP_COUNT  !! name = 0
          RP_BOARD  !! name = Board name title category list!
          RP_POST   !! name = dict!
          RP_THREAD !! name = dict!
      RP_CATMAP !! category = RP_CATMAP.get category dict!
      RP_CATMAP !! category !! name = title
      None

    # Create a new thread, return its ID.
    #
    # :: str str str [(str, str)] -> int
    #
    'thread_create', board title text files ->
      boardo = RP_BOARD !! board
      rootid = RP_COUNT !! board += 1
      root   = Post rootid title False (markup.parse text) files 0 0 datetime.now!
      thread = Thread root list! list! (IntRef 0)

      boardo.threads.insert 0 thread
      config.THREADS_PER_BOARD < len boardo.threads => boardo.threads.pop -1

      VC_BOARD.pop board None  # All pages are invalid now.
      RP_THREAD !! board !! root.id = thread
      RP_POST   !! board !! root.id = root
      rootid

    # Create a new reply, return its ID.
    #
    # :: str int str bool str [(str, str)] -> int
    #
    'post_create', board parent title sage text files ->
      # First, we check `board` and `parent`.
      # If either of these raises a KeyError, one of the
      # values is completely invalid.
      f_board  = RP_BOARD  !! board
      f_parent = RP_POST   !! board !! parent

      # Second, we trace the parenting chain to its origin.
      # We need that info to descend into the correct tree.
      s_parents  = deque!
      s_toplevel = f_parent
      while s_toplevel.parent =>
        s_parents.append s_toplevel.id
        s_toplevel = RP_POST !! board !! s_toplevel.parent

      # Third, we check the thread's constraints.
      t_thread = RP_THREAD !! board !! s_toplevel.id
      t_length = len t_thread.latest + t_thread.skipped.value
      t_length >= config.POSTS_UNTIL_AUTOSAGE => sage = True
      t_length >= config.POSTS_PER_THREAD     => raise OverflowError

      # Fourth, we commence the aforementioned descent into the tree.
      # The trees are, unfortunately, ordered by root ID.
      # That would allow us to use binary search, if it wasn't that cumbersome.
      f_tree = t_thread
      while s_parents =>
        f_pid  = s_parents.pop!
        f_tree = next (None where for t in f_tree.replies => if t.root.id == f_pid => yield t)
  
      # From this point on we cannot afford to bail out.
      # Not that we need to.
      q_id  = RP_COUNT !! board += 1
      q_obj = Post q_id title sage (markup.parse text) files s_toplevel.id parent datetime.now!
      RP_POST !! board !! q_id = q_obj

      f_tree.replies.append $ Tree q_obj list!
      t_thread.latest.append q_obj

      len t_thread.latest > config.POSTS_ON_BOARD_PAGE =>
        t_thread.latest.pop 0
        t_thread.skipped.value += 1

      not sage =>
        q_index = next (None where for (i, t) in enumerate f_board.threads =>
          if t.root.id == s_toplevel.id => yield i)
        f_board.threads !!~ q_index
        f_board.threads.insert 0 t_thread

      VC_BOARD.pop   board                 None
      VC_THREAD.pop (board, s_toplevel.id) None
      q_id
