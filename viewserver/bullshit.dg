import '/re'
import '/dg/Dedent'
import '/dg/EOFTok'
import '/dg/Parser'
import '/jinja2/ext/Extension'


Whitespace  = subclass str where ()
ControlStmt = subclass str where __new__ = t x ~> self where
  self = str.__new__ self x
  self.type = t


BullshitExtension = subclass Extension where
  '''A HAML-like preprocessor for Jinja2.

    Inspired by hamlish-jinja (https://github.com/Pitmairen/hamlish-jinja).

    Unlike hamlish-jinja, however, this thing actually works because it uses
    a real regex-based parser instead of some shitty string manipulations.

  '''
  preprocess = data name _: None ~> if
    name.endswith '.haml.html' => (cls data name).inline '' where
      cls = subclass Bullshit where
        TRIM_SPACES = getattr @environment 'trim_bullshit' False

        # TODO support non-standard delimiters.
        CODE_INLINE  = '{{{{ {} }}}}'.format
        CODE_CONTROL = '{{% {} %}}'  .format
        CODE_COMMENT = '{{# {} #}}'  .format

        TAG_EMPTY = '<{}/>'.format
        TAG_OPEN  = '<{}>' .format
        TAG_CLOSE = '</{}>'.format

        CODE_CLAUSE = set' 'else' 'elif' 'pluralize'
        CODE_VOID   = set' 'else' 'elif' 'pluralize' 'extends' 'from' 'include' 'set' 'import' 'do' 'break' 'continue'
        TAG_VOID    = set' 'area' 'base' 'br' 'col' 'command' 'embed' 'hr' 'img' 'input' 'keygen' 'link' 'meta' 'param' 'source' 'track' 'wbr'
    otherwise => data


Bullshit = subclass Parser where
  inline = data      ~> data + ''.join (takewhile (x -> not $ x in (Dedent, EOFTok)) self)
  block  = start end ~> @inline start! + end!

  regex = re.compile r'''(?imx)
     (?P<newline>\s*\n(?P<newline_indent>\ *))
    |(?P<space>\ +)
    |(?P<comment>;[^\S\n]*(?P<comment_data>.*))
    |(?P<control>-[^\S\n]*(?P<control_data>(?P<control_name>\w+)(?:\ .*)?))
    |(?P<insert>=[^\S\n]*(?P<insert_expr>.*))
    |(?P<tag>%[^\S\n]*(?P<tag_data>(?P<tag_name>\w+)(?:[^\S\n]+[\w-]+(?:=(?:'(?:\\?.)*?'|"(?:\\?.)*?"))?)*)[^\S\n]*(?P<tag_end>->|$))
    |(?P<escape>\\(?P<escaped_text>.*))
    |(?P<text>[^=%\-].*)
    |.
  '''

  token = pos f m ~> if
    f is None      => @error 'invalid input' pos
    f == 'space'   => ''
    f == 'text'    => @inline $ m.group 'text'
    f == 'escape'  => @inline $ m.group 'escaped_text'
    f == 'insert'  => @inline $ @CODE_INLINE  $ m.group 'insert_expr'
    f == 'comment' => @inline $ @CODE_COMMENT $ m.group 'comment_data'
    f == 'tag'     =>
      name = m.group 'tag_name'
      data = m.group 'tag_data'
      end  = m.group 'tag_end'
      if end               => @indent.append $ last @indent + 2
      if name in @TAG_VOID => @inline  $ @TAG_EMPTY data
         otherwise         => @block (-> @TAG_OPEN  data) (-> @TAG_CLOSE name)

    f == 'control' =>
      name = m.group 'control_name'
      data = m.group 'control_data'
      ControlStmt name $ if
        name in @CODE_VOID => @inline $ @CODE_CONTROL data
        otherwise          => @block
           -> @CODE_CONTROL data
           -> '' where
             b = list!
             x = next self
             while x :: Whitespace or (x :: ControlStmt and x.type in @CODE_CLAUSE) =>
               b.insert 0 x
               x = next self

             @append x
             @append $ @CODE_CONTROL $ 'end' + name
             @extend b

    f == 'newline' => '' where
      space =       m.group 'newline'
      level = len $ m.group 'newline_indent'
      @append $ Whitespace $ if (@TRIM_SPACES => ' ') (otherwise => space)
      if level > last @indent => @indent.append level
         otherwise =>
           @append Dedent
           while level != last @indent =>
             @append Dedent
             @indent.pop!
             @indent or @error 'no matching indentation level' pos
