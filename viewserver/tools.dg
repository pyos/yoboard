import '/os/path'
import '/random/choice'
import '/functools/update_wrapper'
import '/subprocess/Popen'
import '/subprocess/PIPE'

import '/flask/abort'
import '/flask/jsonify'
import '/flask/request'

import '../config'
import '../database/Record'

NAMELEN = 22
BASE65  = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.'
STATIC  = '.jpg', '.jpeg', '.png',
ANIM    = '.gif',
VIDEO   = '.webm',
runcmd  = *: argv **: k -> Popen argv **: k


#: Convert an object into its JSON representation. This should be used
#: to respond to `application/json` requests; see `jsflag`.
#:
#: jsreturn :: a -> str
#:
jsreturn = x -> jsonify $ jsprepare x


#: Convert an object into some form that is encodable by `json.dumps`.
#: (This means converting `Record`s into `dict`s. Fields that start
#: with an underscore are not preserved in the output.)
#:
#: jsprepare :: a -> (a - Record)
#:
jsprepare = x -> if
  x :: Record => dict (where for (k, v) in zip x.fields x => k !! 0 != '_' => yield (k, jsprepare v))
  x :: dict   => dict $ zip x.keys! $ map jsprepare x.values!
  x :: list   => list $ map jsprepare x
  otherwise   => x


#: Given a Flask route, make it accept a boolean argument 'isjson' that specifies
#: whether the client has requested an `application/json` file.
#:
#: jsflag :: (** -> Response) -> ** -> Response
#:
jsflag = f -> update_wrapper wrapped: f $ *: a **: k ->
  json = request.accept_mimetypes !! 'application/json'
  html = request.accept_mimetypes !! 'text/html'
  f isjson: (html < json) *: a **: k


#: Given a file upload, give it a name, a thumbnail, and a class.
#: If no class could be given, abort the request. Note that neither the file
#: nor its thumbnail are saved yet; better confirm with the database first.
#:
#: fileinfo :: FileIO -> (str, str, str)
#:
fileinfo = fd ->
  ext   = path.splitext fd.filename !! 1
  name  = ''.join (where for _ in range NAMELEN => yield $ choice BASE65)
  name + ext, name + '.m.jpg', if
    ext in STATIC => ''
    ext in ANIM   => 'anim'
    ext in VIDEO  => 'video'
    otherwise     => abort 400 'Unsupported file type'


#: Store an uploaded file and create a thumbnail.
#:
#:   static images::   the whole image is compressed into available size.
#:   animated images:: the first frame is treated as a static image.
#:   videos::          same as for animated images, only `ffmpeg` is required.
#:
#: fdsave :: FileIO (str, str, str) -> a
#:
fdsave = fd (full, thumb, cls) ->
  full  = path.join config.UPLOAD_DIR full
  thumb = path.join config.UPLOAD_DIR thumb
  size  = '{0}x{0}>'.format config.THUMBNAIL_SIZE
  fd.save full
  if cls == ''      => runcmd 'convert' (full + '[0]') '-resize' size thumb
     cls == 'anim'  => runcmd 'convert' (full + '[0]') '-resize' size thumb
     cls == 'video' =>
       ff = runcmd stdout: PIPE      'ffmpeg' '-v' 'quiet' '-i' full '-vframes' '1' '-f' 'image2' '-'
       im = runcmd stdin:  ff.stdout 'convert' '-' '-resize' size thumb
