import '/os/path'
import '/urllib/parse' qualified
import '/random/choice'
import '/functools/update_wrapper'
import '/subprocess/Popen'
import '/subprocess/PIPE'

import '/dogeweb/abort'
import '/dogeweb/jsonify'

import '../config'
import '../database/Record'

NAMELEN = 22
BASE65  = 'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789-_.'
STATIC  = '.jpg', '.jpeg', '.png',
ANIM    = '.gif',
VIDEO   = '.webm',
runcmd  = *: argv **: k -> Popen argv **: k

ALLTYPES = STATIC + ANIM + VIDEO
ALLLINKS = 'YouTube',


#: Convert an object into its JSON representation. This should be used
#: to respond to `application/json` requests; see `jsflag`.
#:
#: jsreturn :: a -> str
#:
jsreturn = x -> jsonify $ jsprepare x


#: Convert an object into some form that is encodable by `json.dumps`.
#: (This means converting `Record`s into `dict`s. Fields that start
#: with an underscore are not preserved in the output.)
#:
#: jsprepare :: a -> (a - Record)
#:
jsprepare = x -> if
  x :: Record => dict (where for (k, v) in zip x.fields x => k !! 0 != '_' => yield (k, jsprepare v))
  x :: dict   => dict $ zip x.keys! $ map jsprepare x.values!
  x :: list   => list $ map jsprepare x
  otherwise   => x


#: Given a file upload, give it a name, a thumbnail, and a class.
#: If no class could be given, abort the request. Note that neither the file
#: nor its thumbnail are saved yet; better confirm with the database first.
#:
#: fileinfo :: FileIO -> (str, str, str)
#:
fileinfo = fd ->
  ext   = path.splitext fd.name !! 1
  name  = ''.join (where for _ in range NAMELEN => yield $ choice BASE65)
  name + ext, name + '.m.jpg', if
    ext in STATIC => ''
    ext in ANIM   => 'anim'
    ext in VIDEO  => 'video'
    otherwise     => abort 400 'Unsupported file type'


#: Given an external link, create a file description tuple.
#: Note that external links always have "external" as one of their classes
#: and do not have a thumbnail.
#:
#: linkinfo :: str -> (str, str, str)
#:
linkinfo = link ->
  _, loc, path, query, fragment = urllib.parse.urlsplit link
  data        = urllib.parse.parse_qs query
  data.update $ urllib.parse.parse_qs fragment
  if
    loc in ('www.youtube.com', 'youtube.com') and path == '/watch' =>
      # TODO handle `t` (time in `%mm%ss` or `%mm` format.)
      if 'v' in data => data !! 'v' !! 0, '', 'external', 'youtube'
         otherwise   => abort 400 'Invalid YouTube link: no video id'
    loc in ('www.youtube.com', 'youtube.com') and path.startswith '/v/' =>
      path.split '/' !! -1, '', 'external', 'youtube'
    loc == 'youtu.be' =>
      path.split '/' !! 1, '', 'external', 'youtube'
    # TODO Vocaroo and something else.
    otherwise => abort 400 'Unsupported link'


#: Store an uploaded file and create a thumbnail.
#:
#:   static images::   the whole image is compressed into available size.
#:   animated images:: the first frame is treated as a static image.
#:   videos::          same as for animated images, only `ffmpeg` is required.
#:
#: fdsave :: FileIO (str, str, str) -> coroutine a
#:
fdsave = fd (full, thumb, cls) ->
  full  = path.join config.UPLOAD_DIR full
  thumb = path.join config.UPLOAD_DIR thumb
  size  = '{0}x{0}>'.format config.THUMBNAIL_SIZE
  yield from $ fd.save full
  if cls == ''      => runcmd 'convert' (full + '[0]') '-resize' size thumb
     cls == 'anim'  => runcmd 'convert' (full + '[0]') '-resize' size thumb
     cls == 'video' =>
       ff = runcmd stdout: PIPE      'ffmpeg' '-v' 'quiet' '-i' full '-vframes' '1' '-f' 'image2' '-'
       im = runcmd stdin:  ff.stdout 'convert' '-' '-resize' size thumb


import '/os'
import '/time'
import '/random/choice'

import '/jinja2/Environment'
import '/jinja2/PackageLoader'

jinja_env = Environment loader: (PackageLoader __package__ 'templates')
jinja_env.add_extension  $ import '/hamlike/HamlikeExtension'
jinja_env.add_extension  $ import 'markup/MdExtension'
jinja_env.autoescape     = True
jinja_env.trim_blocks    = True
jinja_env.lstrip_blocks  = True
jinja_env.filters.update $ dict'
  'randfile', fd -> choice (os.listdir fd or list' None)
  'relpath',  fp -> os.path.relpath fp $ os.path.dirname config.__file__
  'strftime', ts fmt: '%d.%m.%Y %H:%M:%S' -> time.strftime fmt $ time.localtime ts
  'flattree', xs ->
    ys = list' xs
    for (i, y) in enumerate ys =>
      ys !! i = y.root
      ys.extend y.replies
    ys

jinja_env.globals.update $ dict'
  'config',    config
  'FILETYPES', ALLTYPES
  'LINKTYPES', ALLLINKS


render_template = _n **: args ~>
  tpl = jinja_env.get_template _n
  tpl.render url_for: @url_for **: args
