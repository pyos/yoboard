import '/os'
import '/uuid/uuid4'
import '/flask/Flask'
import '/flask/abort'
import '/flask/redirect'
import '/flask/request'
import '/flask/render_template'
import '/flask/url_for'
import '/subprocess/Popen'

import 'database/picklerpc/Client'
import 'config'


check_post = title text files ->
  '''Ensure that a post matches certain conditions.

    If not, a 400 Bad Request is returned.
    Note that it does not specify a message; the client
    should double-check the data before sending it.

  '''
  config.MAX_UPLOADS < len files             => abort 400
  config.MIN_UPLOADS > len files             => abort 400
  config.MAX_TITLE_LENGTH < len title        => abort 400
  config.MAX_TITLE_LINES <= title.count '\n' => abort 400
  config.MIN_TEXT_LENGTH > len text          => abort 400
  config.MAX_TEXT_LENGTH < len text          => abort 400
  config.MAX_TEXT_LINES <= text.count '\n'   => abort 400


pre_upload = files ->
  '''Generate a list of safe filenames for uploads.

    pre_upload :: [File] -> [(str, str)]

  '''
  list xs where xs = None where
    for f in files !! slice None => if
      f.content_length == 0 and f.filename == '' =>
        # Flask has a tendency to insert that if no files were submitted.
        files.remove f
      otherwise =>
        fn  = uuid4!.hex
        ext = if '.' in f.filename => '.' + f.filename.rpartition '.' !! 2
                 otherwise         => ''

        yield (fn + ext, if
          # TODO: check if imagemagick is installed.
          f.mimetype.startswith 'image/' => fn + '.thumb' + ext
          # Can't downscale that, have to use a FreeDesktop icon.
          # Sadly, icon loader is not implemented yet.
          otherwise => raise Exception
        )


post_upload = fpairs ->
  '''Store the files in a local filesystem & generate thumbnails.

    post_upload :: [(File, (str, str))] -> ()

  '''
  for (file, (fn, tn)) in fpairs =>
    ftg = os.path.join config.UPLOAD_DIR fn
    ttg = os.path.join config.UPLOAD_DIR tn

    file.save ftg
    # TODO: check if ...
    file.mimetype.startswith 'image/' => except
      err => Popen (list' 'convert' ftg '-resize' ('{0}x{0}>'.format config.THUMBNAIL_SIZE) ttg)
      err => # Can't afford to bail out here.
        app.logger.warning 'failed to resize %s: %s: %s' fn err.__class__.__name__ err 


root = ->
  '''Root directory of the module.

    No options.

  '''
  render_template 'index.html' 
    board: ''
    config: config
    boards: data.boards!


board = board page: 0 ->
  '''Listing of threads on a board.

    :param board: alphanumeric ID of the board.

  '''
  data.get_cached_board board page or
    tt, bd, pn = except err => data.board board page
                        err :: KeyError => abort 404
    result = render_template 'board.html'
      this:    bd
      title:   tt
      page:    page
      board:   board
      config:  config
      boards:  data.boards!
      pagenum: pn
    data.set_cached_board board page result
    result


thread_create = board ->
  '''Make a new thread.

    :param board: alphanumeric ID of the board.

    field `title`:: a short summary of the thread.
    field `text`::  initial message.
    field `file`::  any number of attachments.

  '''
  check_post
    title = request.form.get      'title' ''
    text  = request.form.get      'text'  ''
    files = request.files.getlist 'file'
  # A thread cannot be rejected by the database.
  # Still, we need to account for random exceptions.
  fnames = pre_upload files
  thread = except
    err => data.thread_create board title text fnames
    err :: KeyError => abort 404
  post_upload $ zip files fnames
  redirect $ url_for 'thread_redirect' board: board thread: thread


thread_redirect = board thread ->
  '''Redirect to an appropriate thread view.

    :param board: alphanumeric ID of the board.
    :param thread: numeric ID of the thread.

    cookie `view_type`:: type of the view to use (`tree` of `list`).

  '''
  view = request.cookies.get('view_type')

  if view == 'tree' => redirect $ url_for 'thread_tree' board: board thread: thread
     otherwise      => redirect $ url_for 'thread_list' board: board thread: thread


thread_reply = board thread ->
  '''Make a new message.

    :param board: alphanumeric ID of the board.
    :param thread: numeric ID of the thread.

    field `parent`:: the message to reply to.
    field `title`::  a short summary of the message.
    field `sage`::   set iff the author was displeased with the thread.
    field `text`::   a long message.
    field `file`::   any number of attachments.

  '''
  parent = int  $ request.form.get 'parent' thread
  sage   = bool $ request.form.get 'sage'   False
  check_post
    title  = request.form.get      'title' ''
    text   = request.form.get      'text'  ''
    files  = request.files.getlist 'file'
  # This time the database may reject the post
  # if the thread is too big.
  fnames = pre_upload files
  except
    e => data.post_create board parent title sage text fnames
    e :: KeyError      => abort 404
    e :: OverflowError => abort 403
  post_upload $ zip files fnames
  redirect $ url_for 'thread_redirect' board: board thread: thread


thread_tree = board thread ->
  '''View a thread in tree mode.

    :param board: alphanumeric ID of the board.
    :param thread: numeric ID of the thread.

  '''
  data.get_cached_thread board thread 0 or
    th = except err => data.thread board thread
                err :: KeyError => abort 404
    result = render_template 'tree.html'
      this:   th
      board:  board
      config: config
      boards: data.boards!
    data.set_cached_thread board thread 0 result
    result


thread_list = board thread ->
  '''View a thread in list mode.

    :param board: alphanumeric ID of the board.
    :param thread: numeric ID of the thread.

  '''
  data.get_cached_thread board thread 1 or
    as_list = None
    as_list = t ->
      yield t.root
      for q in t.replies => yield from: (as_list q)
    th = except err => data.thread board thread
                err :: KeyError => abort 404
    result = render_template 'list.html'
      this:   th
      posts: (sorted $ as_list th)
      board:  board
      config: config
      boards: data.boards!
    data.set_cached_thread board thread 1 result
    result


data = Client config.CLIENT_ADDRESS
app  = Flask 'yoboard' template_folder: config.TEMPLATE_DIR
app.before_first_request $ -> data.reconnect
app.add_url_rule '/'                           None root
app.add_url_rule '/<board>/'                   None board
app.add_url_rule '/<board>/p<int:page>/'       None board
app.add_url_rule '/<board>/'                   None thread_create methods: (list' 'POST')
app.add_url_rule '/<board>/<int:thread>/'      None thread_redirect
app.add_url_rule '/<board>/<int:thread>/'      None thread_reply methods: (list' 'POST')
app.add_url_rule '/<board>/<int:thread>/tree/' None thread_tree
app.add_url_rule '/<board>/<int:thread>/list/' None thread_list
