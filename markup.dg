import '/re/compile'
import '/itertools/groupby'
import '/collections/deque'
import '/xml/sax/saxutils/escape'

except
  e =>
    import '/pygments/lexers'     qualified
    import '/pygments/formatters' qualified
  e :: ImportError => ()


wrapped = o c -> _ s -> if
  c in s    => ''.join (None where while (q = s.pop!) != c => yield q) + c
  otherwise => s.append c or o

i_re = compile r'''(?ix)
   (?P<code>(`+)(?P<codecontent>.*?)\2)  # NOTE:: `\2` should point to ``(`+)``
  |(?P<strong>\*\*)
  |(?P<emphasis>\*)
  |(?P<deleted>~~)
  |(?P<spoiler>%%)
  |(?P<generic>\b[a-z][a-z0-9+\.-]*:(?:[,\.?]?[^\s(<>)"\',\.?%]|%\d{2}|\([^\s(<>)"\']+\))+)
  |(?P<namedlink>\[(?P<linktitle>.*?)\]\((?P<linktarget>(?:[^()]+|\(.*?\)|[^)])*)\))
  |(?P<escape>\\(?P<escaped>.))
  |(?P<text>[\w-]*[^\W_-]|.)
'''

g_re = compile r'''(?ix)
   (?P<fenced>```)
  |(?P<code>\ {4}|\t)
  |(?P<rule>([*-]\s*){3,}$)
  |(?P<ol>\s*\d+\.\s+)
  |(?P<ul>\s*[*+-]\s+)
  |(?P<quote>\s*>)
  |(?P<break>\s*$)
  |(?P<p>\s*)
'''

i_subst = dict'
  'strong',    '<strong>'               `wrapped` '</strong>'
  'emphasis',  '<em>'                   `wrapped` '</em>'
  'deleted',   '<del>'                  `wrapped` '</del>'
  'spoiler',   '<span class="spoiler">' `wrapped` '</span>'
  'code',      m _ -> '<code>{}</code>'.format $ m.group 'codecontent'
  'generic',   m _ -> '<a href="{0}">{0}</a>'.format $ m.group 0
  'namedlink', m _ -> '<a href="{}">{}</a>'.format (m.group 'linktarget') (m.group 'linktitle')
  'escape',    m _ -> m.group 'escaped'
  'text',      m _ -> m.group 0

g_subst = dict'
  'break',  _  _  -> ''
  'rule',   _  _  -> '<hr />'
  'ol',     _  ys -> '<ol><li>{}</li></ol>'       .format $ '</li><li>'.join $ map i_parse ys
  'ul',     _  ys -> '<ul><li>{}</li></ul>'       .format $ '</li><li>'.join $ map i_parse ys
  'p',      _  ys -> '<p>{}</p>'                  .format $ i_parse $ '\n'.join ys
  'code',   _  ys -> '<pre>{}</pre>'              .format $ escape  $ '\n'.join ys
  'quote',  _  ys -> '<blockquote>{}</blockquote>'.format $ parse' ys
  'fenced', xs ys ->
    code = '\n'.join $ map (x -> x.string) $ takewhile (m -> m.lastgroup != 'fenced') xs
    except
      e => pygments.highlight code
        pygments.lexers.get_lexer_by_name $ next ys
        pygments.formatters.HtmlFormatter!
      e :: Exception => '<pre>{}</pre>'.format $ escape code


i_parse = line ->
  stack = deque!
  i_re.sub (m -> (i_subst !! m.lastgroup) m stack) (escape line) + ''.join (reversed stack)


parse  = text  -> parse' text.splitlines!
parse' = lines ->
  types = map g_re.match lines
  ''.join $ map
    (kind, block) -> (g_subst !! kind) types $
      map (m -> m.string !! slice m.end! None) block
    groupby types (`getattr` 'lastgroup')
